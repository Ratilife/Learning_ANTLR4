grammar STFile;

BOM: '\uFEFF' -> skip;

fileStructure: LBRACE '1' ',' entries RBRACE;

entries: entry (',' entry)*;

entry:
    // Папка: {кол-во_вложений, {"Название", 1, ...}, вложенные_элементы}
    LBRACE count=INT ',' folderHeader ',' nested_entries RBRACE
    |
    // Шаблон: {0, {"Название", 0, ...}}
    LBRACE '0' ',' templateHeader RBRACE
;

nested_entries: entry (',' entry)*;

folderHeader:
    LBRACE
    name=STRING ',' 
    '1' ','  // Тип "Папка" (второй параметр = 1)
    flags=INT ',' 
    param1=STRING ',' 
    param2=STRING
    RBRACE
;

templateHeader:
    LBRACE
    name=STRING ',' 
    '0' ','  // Тип "Шаблон" (второй параметр = 0)
    flags=INT ',' 
    param1=STRING ',' 
    codeBlock=STRING
    RBRACE
;

// Лексемы
INT: [0-9]+;
STRING: '"' ( '\\' . | ~["\\] )* '"';
LBRACE: '{';
RBRACE: '}';
WS: [ \t\r\n]+ -> skip;

Конечно, давайте подробно разберём этот синтаксис ANTLR (Another Tool for Language Recognition). Он описывает структуру файла, который, судя по всему, предназначен для хранения иерархических данных, наподобие файловой системы, где есть папки и шаблоны.

**Общее описание**

Синтаксис предназначен для разбора файлов, которые имеют следующую общую структуру:

* Файл начинается с необязательного символа BOM (Byte Order Mark) `\uFEFF`, который используется для указания порядка байтов в файле.
* Затем идёт основная структура файла, заключённая в фигурные скобки `{}`.
* Внутри этих скобок находится список записей, разделённых запятыми.
* Записи могут быть двух типов: папки и шаблоны.
* Папки могут содержать вложенные записи, а шаблоны — нет.

**Построчное описание**

1.  `grammar STFile;`
    * Это объявление грамматики с именем `STFile`. Оно указывает, что этот файл содержит правила для разбора языка, который мы назвали "STFile".
2.  `BOM: '\uFEFF' -> skip;`
    * Это правило определяет лексему `BOM` (Byte Order Mark).
    * `'\uFEFF'` — это символ Unicode, представляющий BOM.
    * `-> skip` указывает, что этот символ должен быть проигнорирован при разборе, то есть он не будет участвовать в построении дерева разбора.
3.  `fileStructure: LBRACE '1' ',' entries RBRACE;`
    * Это правило определяет структуру всего файла (`fileStructure`).
    * `LBRACE` и `RBRACE` — это лексемы, представляющие открывающую и закрывающую фигурные скобки `{}`.
    * `'1'` — это литерал, который, вероятно, указывает на версию формата файла.
    * `entries` — это правило, которое определяет список записей внутри фигурных скобок.
4.  `entries: entry (',' entry)*;`
    * Это правило определяет список записей (`entries`).
    * `entry` — это правило, которое определяет отдельную запись (папку или шаблон).
    * `(',' entry)*` означает, что после первой записи может следовать ноль или более пар: запятая и ещё одна запись.
5.  `entry:`
    * Это правило определяет, что запись (`entry`) может быть либо папкой, либо шаблоном.
    * `LBRACE count=INT ',' folderHeader ',' nested_entries RBRACE` - описывает структуру папки.
        * `count=INT` - количество вложенных элементов.
        * `folderHeader` - заголовок папки.
        * `nested_entries` - вложенные элементы.
    * `LBRACE '0' ',' templateHeader RBRACE` - описывает структуру шаблона.
        * `'0'` - указывает на то, что это шаблон.
        * `templateHeader` - заголовок шаблона.
6.  `nested_entries: entry (',' entry)*;`
    * Правило аналогично entries, но используется для вложенных элементов папки.
7.  `folderHeader:`
    * Это правило определяет структуру заголовка папки (`folderHeader`).
    * `name=STRING` — имя папки, заключённое в кавычки.
    * `'1'` — литерал, указывающий, что это папка.
    * `flags=INT` — целочисленные флаги.
    * `param1=STRING` и `param2=STRING` — строковые параметры.
8.  `templateHeader:`
    * Это правило определяет структуру заголовка шаблона (`templateHeader`).
    * `name=STRING` — имя шаблона.
    * `'0'` — литерал, указывающий, что это шаблон.
    * `flags=INT` — целочисленные флаги.
    * `param1=STRING` и `codeBlock=STRING` — строковые параметры, codeBlock, вероятно, содержит код шаблона.
9.  `INT: [0-9]+;`
    * Это правило определяет лексему `INT` (целое число).
    * `[0-9]+` означает одну или более цифр от 0 до 9.
10. `STRING: '"' ( '\\' . | ~["\\] )* '"';`
    * Это правило определяет лексему `STRING` (строка).
    * `'"'` — открывающая кавычка.
    * `( '\\' . | ~["\\] )*` — ноль или более символов, которые могут быть экранированными символами (`'\\'.`) или любыми символами, кроме кавычек и обратных слешей (`~["\\]`).
    * `'"'` — закрывающая кавычка.
11. `LBRACE: '{';`
    * Это правило определяет лексему `LBRACE` (открывающая фигурная скобка).
12. `RBRACE: '}';`
    * Это правило определяет лексему `RBRACE` (закрывающая фигурная скобка).
13. `WS: [ \t\r\n]+ -> skip;`
    * Это правило определяет лексему `WS` (пробельный символ).
    * `[ \t\r\n]+` означает один или более пробельных символов (пробел, табуляция, возврат каретки, новая строка).
    * `-> skip` указывает, что эти символы должны быть проигнорированы.

**Функционал**

Этот синтаксис позволяет:

* Разбирать файлы с иерархической структурой данных.
* Различать папки и шаблоны.
* Извлекать имена, флаги и параметры папок и шаблонов.
* Обрабатывать вложенные записи в папках.
* Игнорировать BOM и пробельные символы.

Пример корректного входного файла:
{1, {"Папка1", 1, 0, "параметр1", "параметр2"}, {
    {0, {"Шаблон1", 0, 1, "параметр1", "код1"}},
    {0, {"Шаблон2", 0, 1, "параметр1", "код2"}}
}}

Этот синтаксис может быть использован для создания парсера, который сможет читать и обрабатывать файлы описанного формата.
